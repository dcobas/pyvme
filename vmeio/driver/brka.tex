\documentclass{article}
\usepackage{paralist,fancyvrb}

\title{The Baraka System}
\author{Juan David Gonz\'alez Cobas}

\newtheorem{note}{Note}

\begin{document}

\maketitle

\section{The \texttt{vmeio} kernel module}

\subsection{Installation of \texttt{vmeio.ko}}

This module provides the basic kernel-space facility for VME bus
raw~I/O. It is mainly due to the efforts of Julian Lewis.

To install it, the only pre-requisite is a Linux system running the
\texttt{vmebridge} driver. A typical installation is as follows:
\begin{Verbatim}
    # insmod vmeio.ko \
        vme1=0x800,0xC00  amd1=0x29,0x29 win1=0x400,0x400 dwd1=4,4 \
	vme2=0x8100,0x8200 amd2=0x29,0x29 win2=0x100,0x100 dwd2=2,2 \
	vecs=0x83,0x84 lvls=2,2 luns=0,2
\end{Verbatim}
This command installs the \verb|vmeio| driver and instructs it to handle
two modules, referred to later by unit numbers 0 and 2. In this
particular example, we are dealing with two CVORG modules. The first
one, assigned unit number 0, has two register spaces that are
memory-mapped and an interrupt to be handled. The first mapping
is described by
\begin{compactdesc}
\item[vme base address] 0x800
\item[address modifier] 0x29 (A16 non-privileged)
\item[range or size of the window mapped] 0x400
\item[data width] 4 (32-bit data)
\end{compactdesc}
and the second by
\begin{compactdesc}
\item[vme base address] 0x8100
\item[address modifier] 0x29 (A16 non-privileged)
\item[range or size of the window mapped] 0x100
\item[data width] 2 (16-bit data)
\end{compactdesc}
The interrupt is at level 2, vector 0x83.

The second module has a similar set of data to be declared. For that
purpose, the insmod arguments are actually arrays, and the values in
them are correlative. So, the second CVORG module, to which we assign
the arbitrary unit number 2, has the same paramenters as CVORG number
zero, except that its base addresses are now 0xC00 and 0x8200, and that
it uses interrupt vector 0x84.

The complete list of arguments is the following
\begin{compactdesc}
\item[luns] Array of logical unit numbers assigned to the modules.
    These are different non-negative integers inferior to 32. All the
    remaining array arguments must have the same number of elements and
    correspond to the modules indexed by these luns.
\item[vecs] Array of interrupt vectors corresponding to the modules
    enumerated in \verb|luns|.
\item[lvls] Array of interrupt levels.
\item[vme1, vme2] Arrays of base addresses for the first and second
    register map of each module
\item[win1, win2] Arrays of sizes for the first and second register map
    of each module
\item[amd1, amd2] Arrays of address modifiers for the first and second 
    register map of each module
\item[dwd1, dwd2] Arrays of data widths for the first and second register map
    of each module (1, 2 or 4 meaning 8, 16 or 32-bit access).
\item[nmap] Non-map flag. If \verb|nmap=1|, no windows are mapped and
    accesses will be done via block transfers instead of MMIO.
\item[isrc] Vector of offsets of the interrupt source register in the
    first register map
\end{compactdesc}

To avoid repeating values that are always identical in a module, the
convention is adopted that a single-valued array argument is repeated as
many times as luns are declared. So, we could abbreviate the command
above to
\begin{Verbatim}
   # insmod vmeio.ko    \
	luns=0,2 \
	vme1=0x800,0xC00   amd1=0x29 win1=0x400  dwd1=4  \
	vme2=0x8100,0x8200 amd2=0x29 win2=0x100  dwd2=2  \
	vecs=0x83,0x84     lvls=2
\end{Verbatim}

\begin{note}
This feature is probably best deprecated, and the arguments that need
not be vectors (amd*, win*, lvls, isrc) declared as non-array parameters
\end{note}
\begin{note}
Probably, a simple GUI generating the list of parameters can make
people's life easier
\end{note}
\begin{note}
The argument names are admittedly confusing; I would advocate to use
explicit names like \begin{rm}
\begin{Verbatim}
    base_address
    address_modifier
    data_width
    window_size
    vectors
    level
\end{Verbatim}
\end{rm}
\end{note}
\begin{note}
Another improvement here should be the possibility to install the module
without any parameter, and set mappings and IRQs dynamically. To be done
from Python.
\end{note}
\begin{note}
The following section on making device nodes should not be necessary;
the device nodes should be created via \texttt{sysfs}, which takes out a
real burden from the installation.
\end{note}

\subsection{Creating device nodes}

By default, accessing the declared cards is done through device nodes
named \verb|/dev/vmeio.|$x$, where~$x$ is the unit number associated in
the \verb|insmod| command line to the module. Device nodes are created
manually by issuing a command like
\begin{Verbatim}
    # mknod /dev/vmeio.0 c $MAJOR 0
    # mknod /dev/vmeio.2 c $MAJOR 2
\end{Verbatim}
where MAJOR is the major device number associated to \verb|vmeio| at
installation time. It can be found out in the /verb|/proc/devices| file

\begin{note}
This needs to be automated.
\end{note}

\section{The \texttt{pyvme} interface}

The access to a VME device is provided by the python module
\verb|pyvme|. It provides a simple \verb|Vme| class definition
documented the usual pythonic way. An HTML doc is provided in the
install directory.

An object is instantiated with the unit number that refers to it:
\begin{Verbatim}
	ctr = pyvme.Vme(2)
\end{Verbatim}
From now on, ctr refers to the second module described at \verb|vmeio|
installation time. Now, methods for raw I/O, DMA analogous of them and
for waiting for an interrupt with timeout are provided. Look for
\verb|pyvme.html| in the install directory: the usage is pretty
straightforward.

\end{document}

