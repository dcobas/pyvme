#!   /usr/bin/env	python
#    coding: utf8

import sys
import os
import errno
import stat
import datetime
import string
import csv
import ccdb
import cx_Oracle
from os.path import join
from optparse import OptionParser

db_am_translate = {
    2 : 0x39,
    4 : 0x2f,
    5 : 0x29,
    7 : 0x9,
}

def gen_plain_file(register_list, filename):
    """given a list of dicts with registers, construct a columnated file"""

    out = open(filename, 'wb')
    for reg in register_list:
        for key in ccdb.Register.fields:
            out.write('%s\t' % reg[key])
        out.write('\n')
    out.close()

def gen_csv_file(register_list, filename):
    """given a list of dicts with registers, construct a CSV file"""

    out = csv.DictWriter(open(filename, 'wb'), ccdb.Register.fields)
    for reg in register_list:
        out.writerow(reg)

def get_csv_data(register_list, filename):
    """get register data from a CSV file"""

    inp = csv.DictReader(file(filename), ccdb.Register.fields)
    return [ reg for reg in inp ]

def gen_register_struct(register_list, module_name):
    """create a C structure definition for this register list"""

    # generate include file
    template = file(regs_h_template).read()
    register_names = [ '\t' + reg['name'] + ',\n' for reg in register_list ]
    register_names = ''.join(register_names)
    driver_name = module_name
    device_name = driver_name.upper()
    include_file = template % locals()

    cstruct = [
        '#include "vmeio.h"\n',
        '#include "%s_regs.h"\n\n' % driver_name,
        'struct encore_reginfo %s_registers[] = {\n\n' % module_name ]
    for reg in register_list:
        cstruct.append('[%(name)s] = {\n' % reg)
        cstruct.append('''\
\t.name	        	= "%(name)s",
\t.rwmode      		= "%(rwmode)s",
\t.block       		= %(block)d,
\t.block_address_space	= %(block_address_space)d,
\t.block_offset		= 0x%(block_offset)x,
\t.register_offset	= 0x%(register_offset)x,
\t.offset			= 0x%(offset)x,
\t.wordsize	    	= "%(wordsize)s",
\t.depth       		= 0x%(depth)x,
\t.description		= "%(description)s",
\t.data_width		= %(data_width)d,'''
                       '\n    },\n\n''' % reg )
    cstruct.append('};\n\n')
    cstruct.append(
	'int %s_nregs = '
	'sizeof(%s_registers)/sizeof(%s_registers[0]);\n' % (
		module_name, module_name, module_name))
    c_file =  ''.join(cstruct)
    return include_file, c_file

def gen_register_struct_file(register_list, module_name, hname, cname):
    """generate a C file with struct encore definitions"""
    h, c = gen_register_struct(register_list, module_name)
    outh = file(hname, 'w')
    outh.write(h)
    outh.close()
    outc = file(cname, 'w')
    outc.write(c)
    outc.close()

def gen_lib_module(register_list, driver_name):
    """generate declarations of module lib API"""

    get_proto_template = (
        'int %(driver_name)s_get_%(name)s(int fd, %(wordsize)s *buf);\n' )
    set_proto_template = (
		'int %(driver_name)s_set_%(name)s(int fd, %(wordsize)s buf);\n' )
    get_window_proto_template = (
		'int %(driver_name)s_get_%(name)s_window(int fd, %(wordsize)s buf[], int from, int to);\n' )
    set_window_proto_template = (
		'int %(driver_name)s_set_%(name)s_window(int fd, %(wordsize)s buf[], int from, int to);\n' )

    get_template = """
int %(driver_name)s_get_%(name)s(int fd, %(wordsize)s *buf)
{
	struct encore_reginfo *reg = &%(driver_name)s_registers[%(name)s];
	return get_set_register(fd, reg, buf, READ);
}
"""
    set_template = """
int %(driver_name)s_set_%(name)s(int fd, %(wordsize)s buf)
{
	struct encore_reginfo *reg = &%(driver_name)s_registers[%(name)s];
	return get_set_register(fd, reg, &buf, WRITE);
}
"""
    get_window_template = """
int %(driver_name)s_get_%(name)s_window(int fd, %(wordsize)s buf[], int from, int to)
{
	struct encore_reginfo *reg = &%(driver_name)s_registers[%(name)s];
	return get_set_window(fd, reg, buf, from, to, READ);
}
"""
    set_window_template = """
int %(driver_name)s_set_%(name)s_window(int fd, %(wordsize)s buf[], int from, int to)
{
	struct encore_reginfo *reg = &%(driver_name)s_registers[%(name)s];
	return get_set_window(fd, reg, buf, from, to, WRITE);
}
"""

    lib = [ ]
    h   = [ ]
    lib.append(file(lib_module_c_template).read() % locals())
    h.append(file(lib_module_h_template).read() % locals())
    for reg in register_list:
        reg['driver_name'] = driver_name
        if 'r' in reg['rwmode']:
            lib.append(get_template % reg)
            h.append(get_proto_template % reg)
            if reg['depth'] > 1:
                lib.append(get_window_template % reg)
                h.append(get_window_proto_template % reg)
        if 'w' in reg['rwmode']:
            lib.append(set_template % reg)
            h.append(set_proto_template % reg)
            if reg['depth'] > 1:
                lib.append(set_window_template % reg)
                h.append(set_window_proto_template % reg)
    return ''.join(h), ''.join(lib)

def gen_lib_module_file(register_list, driver_name, lib_c, lib_h):
    h, lib  = gen_lib_module(register_list, driver_name)
    hfile = file(lib_h, 'w')
    hfile.write(h)
    hfile.close()
    cfile = file(lib_c, 'w')
    cfile.write(lib)
    cfile.close()


def gen_regs(register_list, module_name):

    rwmode_translate = {
        "rw"	: "RW",
        "rc"	: "RO",
        "rc"	: "RO",
        "r"	    : "RO",
        "w" 	: "RW",
        "rw"	: "RW",
        "e"     : "WO",
        "rc"	: "RO",
        "rwc"	: "RW",
    }

    size_translate = {
        'long'  : 4,
        'short' : 2,
        'char'  : 1,
    }

    row_template = ( "$\t%(register_name)-16s\t%(rwflags)2s\t"
            "0x%(offset)08X\t%(size)d\t%(window)d\t%(depth)s\n")
    regs = []
    for register in register_list:
        register_name = register['name']
        rwflags = rwmode_translate[register['rwmode']]
        offset = int(register['offset'])
        size = int(size_translate[register['wordsize']])
        window = 1
        depth = int(register['depth'])
        row = row_template % locals()
        regs.append(row)
    return ''.join(regs)

def gen_regs_file(register_list, module_name):
    """produce a .regs file"""

    name = module_name.upper()
    header = """NAME %s

  RegName		RwFlags	Offset		Size	Window	Depth

""" % name

    upper_name = name.upper()
    out = open(upper_name+'.regs', 'wb')
    out.write(header)
    out.write(gen_regs(register_list, upper_name))
    out.close()

def gen_driver(driver_name, filename):
    """produce a driver with register data"""

    template = file(driver_template).read()
    template = string.Template(template)
    date = datetime.datetime.now().isoformat(' ')
    driver = template.substitute(locals())
    out = open(filename, 'wb')
    out.write(driver)
    out.close()

def gen_makefile(driver_name, module_name, filename):
    """produce a Makefile for the library"""

    template = file(makefile_template).read()

    date = datetime.datetime.now().isoformat(' ')
    makefile = template % locals()
    out = open(filename, 'wb')
    out.write(makefile)
    out.close()

def gen_kbuild(driver_name, module_name, filename):
    """produce a Kbuild for the driver"""

    template = file(kbuild_template).read()

    date = datetime.datetime.now().isoformat(' ')
    kbuild = template % locals()
    out = open(filename, 'wb')
    out.write(kbuild)
    out.close()

def gen_install_script(device_name, driver_name,
	output_file, transfer='/etc/transfer.ref'):

    template = file(instprog_template).read()

    date = datetime.datetime.now().isoformat(' ')
    out = file(output_file, 'w')
    out.write(template % locals())
    out.close()

def gen_delivery_script(driver_name, output_file):

    template = file(deliver_template).read()

    date = datetime.datetime.now().isoformat(' ')
    out = file(output_file, 'w')
    out.write(template % locals())
    out.close()

def make_out_dir(dirname, kill=False):
    try:
        isdir = stat.S_ISDIR(os.stat(dirname).st_mode)
        if not kill and raw_input(dirname +
                ' already exists, remove? (y/N) ') != 'y':
            return -errno.ENOENT

        for root, dirs, files in os.walk(dirname, topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
            for name in dirs:
                os.rmdir(os.path.join(root, name))
        os.rmdir(dirname)
        return os.mkdir(dirname)
    except OSError:
        return os.mkdir(dirname)

def main():

    # option processing
    usage = 'usage: dbexctract.py [options] MODULE_NAME'

    parser = OptionParser(usage=usage)
    parser.add_option("--plain", dest="plain", action="store",
                        help="create a plaintext file with register data",
                        metavar="FILE")
    parser.add_option("--regs", action="store_true", dest="regs",
                        help="create a .regs file for encore v1.0 compat",
                        metavar="FILE")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")
    parser.add_option("-k", "--kill",
                      action="store_true", dest="kill", default=False,
                      help="kill destination directory if it exists")
    parser.add_option("--csv",
                      action="store_true", dest="csv",
                      help="do not query the CCSB, read from a CSV file instead")
    (options, args) = parser.parse_args(sys.argv)

    # only positional parameter, module name
    if len(args) != 2:
        parser.print_help()
        sys.exit(1)
    module_name = args[1].upper()

    # prepare output paths
    driver_name   = module_name.lower().replace('-', '_')
    output_dir    = driver_name
    libname       = 'lib_%s' % driver_name
    makefile      = join(output_dir, 'Makefile')
    kbuild        = join(output_dir, 'Kbuild')
    driver_c      = join(output_dir, driver_name + '.c')
    regs_csv      = join(output_dir, driver_name + '_regs.csv')
    mod_csv       = join(output_dir, driver_name + '_mod.csv')
    regs_h	      = join(output_dir, driver_name + '_regs.h')
    regs_c	      = join(output_dir, driver_name + '_regs.c')
    lib_h	      = join(output_dir, libname + '.h')
    lib_c	      = join(output_dir, libname + '.c')
    install_sh	  = join(output_dir, 'install_' + driver_name + '.sh')
    deliver_sh	  = join(output_dir, 'deliver.sh')

    if make_out_dir(output_dir, options.kill):
        print 'could not make output dir ' + output_dir
        sys.exit(1)

    try:
        if options.csv:
            in_regs_csv      = join(driver_name + '_regs.csv')
            in_mod_csv       = join(driver_name + '_mod.csv')
            module = ccdb.query_csv(in_mod_csv, in_regs_csv)
            register_list = module.registers
        else:
            module = ccdb.query_db(module_name)
            register_list  = module.registers
    except TypeError:
        register_list = None
    if not register_list:
        print 'no data for module %s in CCDB, exiting' % module_name
        sys.exit(1)

    # copy verbatim files and locate templates
    # cwd = os.path.dirname(sys.argv[0])
    for f in verbatim_files:
        from_ = os.path.join(templates_dir, f)
        to    = os.path.join(output_dir, f)
        if f == 'vmeio.c':
            to = os.path.join(output_dir, driver_name + '.c')
	os.system('cp "%s" "%s"' % (from_, to))

    # driver fileset generation
    gen_csv_file(register_list, regs_csv)
    gen_driver(driver_name, driver_c)
    gen_register_struct_file(register_list, driver_name, regs_h, regs_c)
    gen_makefile(driver_name, module_name, makefile)
    gen_kbuild(driver_name, module_name, kbuild)
    gen_install_script(module_name, driver_name, install_sh)
    gen_delivery_script(driver_name, deliver_sh)
    gen_lib_module_file(register_list, driver_name, lib_c, lib_h)

    # optional data files generation
    registers = dict([ (regdata['name'], regdata)
                        for regdata in register_list ])
    if options.plain:
        plain_filename =join(output_dir, options.plain)
        gen_plain_file(register_list, plain_filename)
    if options.regs:
        regs_filename = join(output_dir, module_name)
        gen_regs_file(register_list, regs_filename)

# verbatim files and templates
prog_dir              = os.path.dirname(sys.argv[0])
templates_dir         = os.path.join(prog_dir, 'templates')
driver_template       = os.path.join(templates_dir, 'vmeio.c')
makefile_template     = os.path.join(templates_dir, 'Makefile')
kbuild_template       = os.path.join(templates_dir, 'Kbuild')
deliver_template      = os.path.join(templates_dir, 'deliver.sh')
instprog_template     = os.path.join(templates_dir, 'install.sh')
regs_h_template       = os.path.join(templates_dir, 'module_regs.h')
lib_module_h_template = os.path.join(templates_dir, 'lib_module.h')
lib_module_c_template = os.path.join(templates_dir, 'lib_module.c')
verbatim_files = [
    'vmeio.h',
    'Module.symvers.vmebus',
    'transfer2insmod.awk',
]

if __name__ == '__main__':

    main()

