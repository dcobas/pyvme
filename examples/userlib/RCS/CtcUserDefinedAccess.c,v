head	1.3;
access;
symbols;
locks
	lewis:1.3; strict;
comment	@ * @;


1.3
date	2010.12.09.16.28.33;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.09.15.14.05;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2010.12.08.17.48.36;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.3
log
@*** empty log message ***
@
text
@/*
 * A legacy DGII interface base to save modifying client code
 * I just do the minimun needed to get the old API working
 * Some of this looks like crap, but I strictly replicate the
 * old behaviour towards the hardware, just in case.
 *
 * Wed 8th Dec 2010 CO/HT Julian Lewis
 */

#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sched.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <dlfcn.h>
#include <unistd.h>
#include <errno.h>

/*
 * About the type HANDLE used in the old drivers genII.
 * Here it is actually a pointer to a support library
 * handle and should have been obtained from the OPEN
 * support library function. This will require a small
 * modification to the client code.
 */

#include <CtcUserDefinedAccess.h>

typedef struct {
	int confChan;
	int clock1Delay;
	int clock2Delay;
	int outputCntr;
	int cntr1CurVal;
	int cntr2CurVal;
} ctc_channel_s;

struct ctc_map_s {
	int           status;
	int           cntr_enable;
	ctc_channel_s channels[L_OUT_CH];
};

struct ctc_map_s *map = NULL; /* Just for getting addresses */

int ctc_lib_glob_dbg_flag = 0;

/**
 * =====================================================================
 * Helper routines to call RAW IO and handle errors
 */

#define DO_READ 0
#define DO_WRITE 1

static int do_io(HANDLE handle, int *offset, int *data, int flag)
{
	struct vmeio_riob_s buf;

	buf.winum  = 1;
	buf.offset = (int) offset;
	buf.bsize  = 4;
	buf.buffer = data;

	if (!RAW(handle,&buf,flag))
		return 0;
	return 1;
}

static int do_error(int err) {

	char *cp;

	if (ctc_lib_glob_dbg_flag) {
		if (err == CTC_CH_OUT_OF_RANGE)
			cp = "Channel Out of Range";
		else if (err == CTC_VAL_OUT_OF_RANGE)
			cp = "Value Out of Range";
		else if (err == CTC_ERR)
			cp = "General CTC Error";
		else if (err == CTC_DAL_ERR)
			cp = "Driver Access Library Error";
		else
			cp = "???";

		fprintf(stderr,"CtcUserDefinedAccess: Error:%d [%s]\n",err,cp);
	}
	return -err;
}

/**
 * =====================================================================
 * @@brief Get input channel (i.e. external start) of output channel
 *        in question.
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - [1, 40] external start channel
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - channel out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getInputChan(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	locRes = ((locRes & CHCFG_ESC_MASK) >> CHCFG_ESC_SHIFT) + 1;
	*res = locRes;

	return OK;
}

/**
 * =====================================================================
 * @@brief Input (i.e. external start) <-> output channel mapping.
 *
 * @@param handle - DAL handle
 * @@param chan   - output channel. [1, 8] range
 * @@param newVal - input channel. [1, 40] range.
 *                 If zero - then module resetting requested.
 *                 Will be set to default external trigger (i.e. input channel)
 *                 namely the first one.
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_setInputChan(HANDLE handle, int chan, unsigned long newVal)
{
	int curVal;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (newVal > L_INP_CH)
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&curVal,DO_READ))
		return do_error(CTC_DAL_ERR);

	curVal &= ~(CHCFG_ESC_MASK);
	if (newVal)
		curVal |= (((newVal - 1) & CHCFG_ESC_SIGBITS_MASK) << CHCFG_ESC_SHIFT);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	return OK;
}

/**
 * =====================================================================
 * @@brief Returns current clock setting for the first counter.
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - reg val will be put here
 *
 * @@note Real register value will be interpreted here, since the clock setting,
 *       as seen by the user is (reg_value + 1), i.e.\n
 *       0 - clock1\n
 *       1 - clock2 etc...
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getClock1(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	locRes = (locRes & CHCFG_C1S_MASK) >> CHCFG_C1S_SHIFT;
	*res = locRes + 1;

	return OK;
}

/**
 * =====================================================================
 * @@brief Set external clock for the first counter.
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param newVal - value to set [1, 6]
 *
 * @@note Provided user value will be interpreted, since the the real clock
 *       setting is (user_value - 1), i.e.\n
 *       0 - clock1\n
 *       1 - clock2 etc...
 *
 * @@return OK                    - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE  - input/output chan out of range
 * @@return -CTC_VAL_OUT_OF_RANGE - requested external clock is out-of-range
 * @@return -CTC_DAL_ERR          - DAL return error
 */

int ctc_setClock1(HANDLE handle, int chan, unsigned long newVal)
{
	int curVal;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if ((newVal < 1) || (newVal > 6))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&curVal,DO_READ))
		return do_error(CTC_DAL_ERR);

	curVal &= ~(CHCFG_C1S_MASK);  /* cleanout old value */
	curVal |= (((newVal - 1) & CHCFG_C1S_SIGBITS_MASK) << CHCFG_C1S_SHIFT);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	return OK;
}

/**
 * =====================================================================
 * @@brief Returns current clock setting for the second counter.
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - reg val will be put here
 *
 * @@note Real register value will be interpreted here, since the clock setting,
 *       as seen by the user is (reg_value + 1), i.e.\n
 *       0 - clock1\n
 *       1 - clock2 etc...
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getClock2(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	locRes = (locRes & CHCFG_C2S_MASK) >> CHCFG_C2S_SHIFT;
	*res = locRes + 1;

	return OK;
}

/**
 * =====================================================================
 * @@brief Set external clock for the second counter.
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param newVal - value to set [1, 6]
 *
 * @@note Provided user value will be interpreted, since the the real clock
 *       setting is (user_value - 1), i.e.\n
 *       0 - clock1\n
 *       1 - clock2 etc...
 *
 * @@return OK                    - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE  - input/output chan out of range
 * @@return -CTC_VAL_OUT_OF_RANGE - requested external clock is out-of-range
 * @@return -CTC_DAL_ERR          - DAL return error
 */

int ctc_setClock2(HANDLE handle, int chan, unsigned long newVal)
{
	int curVal;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if ((newVal < 1) || (newVal > 6))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&curVal,DO_READ))
		return do_error(CTC_DAL_ERR);

	curVal &= ~(CHCFG_C2S_MASK);  /* cleanout old value */
	curVal |= (((newVal - 1) & CHCFG_C2S_SIGBITS_MASK) << CHCFG_C2S_SHIFT);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].confChan),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	return OK;
}

/**
 * =====================================================================
 * @@brief
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - reg val will be put here
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getClock1Tick(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].clock1Delay),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	*res = locRes;
	return OK;
}

/**
 * =====================================================================
 * @@brief
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param newVal - value to set
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_setClock1Tick(HANDLE handle, int chan, unsigned long newVal)
{
	int curVal;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	curVal = 0;
	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].clock1Delay),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	curVal = newVal;
	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].clock1Delay),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	return OK;
}

/**
 * =====================================================================
 * @@brief
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - reg val will be put here
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getClock2Tick(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].clock2Delay),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	*res = locRes;
	return OK;
}

/**
 * =====================================================================
 * @@brief
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param newVal - value to set
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_setClock2Tick(HANDLE handle, int chan, unsigned long newVal)
{
	int curVal;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	curVal = 0;
	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].clock2Delay),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	curVal = newVal;
	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].clock2Delay),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	return OK;
}

/**
 * =====================================================================
 * @@brief
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - reg val will be put here
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getOutPutCounter(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].outputCntr),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	*res = locRes;
	return OK;
}

/**
 * =====================================================================
 * @@brief Get current value of the 1'st counter.
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - reg val will be put here
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getCntr1CurVal(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].cntr1CurVal),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	*res = locRes;
	return OK;
}

/**
 * =====================================================================
 * @@brief Get current value of the 2'nd counter.
 *
 * @@param handle - DAL handle
 * @@param chan   - [1, 8] range
 * @@param res    - reg val will be put here
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_getCntr2CurVal(HANDLE handle, int chan, unsigned long *res)
{
	int locRes;

	if ((chan < F_OUT_CH) || (chan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->channels[chan - F_OUT_CH].cntr2CurVal),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	*res = locRes;
	return OK;
}

/**
 * =====================================================================
 * @@brief Obtain module status register (get current Hardware version).
 *
 * @@param handle - DAL handle
 * @@param res    - reg val will be put here
 *
 * @@return OK           - if succeed. i.e. 0
 * @@return -CTC_DAL_ERR - DAL return error
 */

int ctc_getModuleStatus(HANDLE handle, unsigned long *res)
{
	int locRes;

	if (!do_io(handle,&(map->status),&locRes,DO_READ))
		return do_error(CTC_DAL_ERR);

	*res = locRes;
	return OK;
}

/*
 * =====================================================================
   RESET register bit layout:

   Only 9 LSB are taken into account [0 - 8].
   First one is to reset the whole module.
   All the rest are to enable/disable channels. bit 1 - channel 8,
   bit 2 - channel 7 ... bit 8 - channel 1

   bit:    8     7     6     5     4     3     2     1        0
        +-----+-----+-----+-----+-----+-----+-----+-----+-----------+
        | ch1 | ch2 | ch3 | ch4 | ch5 | ch6 | ch7 | ch8 | mod reset |
        +-----+-----+-----+-----+-----+-----+-----+-----+-----------+

   To enable the channel  - write 1 to appropriate bit.
   To disable the channel - write 0 to appropriate bit.
   To reset the module    - write 1 to the bit zero.
 */

/**
 * =====================================================================
 * @@brief Reset module and disable all the channels.
 *
 * @@param handle - DAL handle
 *
 * @@return OK           - if succeed. i.e. 0
 * @@return -CTC_DAL_ERR - DAL return error
 * @@return -CTC_ERR     - ctc lib function error
 */

int ctc_resetModule(HANDLE handle)
{
	int curRegVal;
	int cntr;

	if (!do_io(handle,&(map->cntr_enable),&curRegVal,DO_READ))
		return do_error(CTC_DAL_ERR);

	curRegVal = 1;
	if (!do_io(handle,&(map->cntr_enable),&curRegVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);


	curRegVal = 0; /* change module reset bit to zero and reset all the channels,
			  so that next time we'll write some value into reset
			  register, no module reset will be performed by accident */

	if (!do_io(handle,&(map->cntr_enable),&curRegVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	if (!do_io(handle,&(map->cntr_enable),&curRegVal,DO_READ))
		return do_error(CTC_DAL_ERR);

	/* set all channel inputs and counter delays to zero */

	for (cntr = 1; cntr <= 8; cntr++)
		if ( ctc_setInputChan(handle, cntr, 0) ||
		     ctc_setClock1Tick(handle, cntr,0) ||
		     ctc_setClock2Tick(handle, cntr,0) ) {
	      return do_error(CTC_ERR);
	}
       return OK;
}

/**
 * =====================================================================
 * @@brief Set input <-> output channel mapping and enable specified
 *        output channel.
 *
 * @@param handle  - DAL handle
 * @@param outChan - output channel.[1,  8] range
 * @@param inpChan - input channel. [1, 40] range
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 * @@return -CTC_ERR             - ctc lib function error
 */

int ctc_enableChannel(HANDLE handle, int outChan, int inpChan)
{
	int curVal;

	if ((outChan < 1) || (outChan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if ((inpChan < 1) || (inpChan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	/* set input channel in config register of the channel */

	if (ctc_setInputChan(handle, outChan, inpChan))
		return do_error(CTC_ERR);

	if (!do_io(handle,&(map->cntr_enable),&curVal,DO_READ))
		return do_error(CTC_DAL_ERR);

	curVal |= 1 << (F_OUT_CH + L_OUT_CH - outChan);

	if (!do_io(handle,&(map->cntr_enable),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	return OK;
}

/**
 * =====================================================================
 * @@brief Disable specified output channel and unset input <-> output channel
 *        mapping.
 *
 * @@param handle  - DAL handle
 * @@param outChan - output channel to disable. [1, 8] range
 *
 * To disable channel, we should write 0 to the corresponding bit of the reset
 * register. Moreover, current external start (input channel) is set to zero.
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

int ctc_disableChannel(HANDLE handle, int outChan)
{
	int curVal;

	if ((outChan < 1) || (outChan > L_OUT_CH))
		return do_error(CTC_CH_OUT_OF_RANGE);

	if (!do_io(handle,&(map->cntr_enable),&curVal,DO_READ))
		return do_error(CTC_DAL_ERR);

	curVal &= ~(1 << (F_OUT_CH + L_OUT_CH - outChan));

	if (!do_io(handle,&(map->cntr_enable),&curVal,DO_WRITE))
		return do_error(CTC_DAL_ERR);

	return OK;
}

/**
 * =====================================================================
 * @@brief To get channel configuration data.
 *
 * @@param handle  - DAL handle
 * @@param outChan - Junk argument
 *
 * @@return OK                   - if succeed. i.e. 0
 * @@return -CTC_CH_OUT_OF_RANGE - input/output chan out of range
 * @@return -CTC_DAL_ERR         - DAL return error
 */

ctc_cfg_reg_t *ctc_getChanConf(HANDLE handle, int outChan)
{
	static ctc_cfg_reg_t ctc_conf_data[L_OUT_CH]; /* Horrible, not thread safe */
	int curVal, cntr;

	for (cntr = 0; cntr < L_OUT_CH; cntr++) {
		if (!do_io(handle,&(map->channels[cntr].confChan),&curVal,DO_WRITE))
			return (ctc_cfg_reg_t *) do_error(CTC_DAL_ERR);
		ctc_conf_data[cntr].cr_ext_start = ((curVal & CHCFG_ESC_MASK) >> CHCFG_ESC_SHIFT) + 1;
		ctc_conf_data[cntr].cr_cntr1_clk = ((curVal & CHCFG_C1S_MASK) >> CHCFG_C1S_SHIFT) + 1;
		ctc_conf_data[cntr].cr_cntr2_clk = ((curVal & CHCFG_C2S_MASK) >> CHCFG_C2S_SHIFT) + 1;
		ctc_conf_data[cntr].cr_mode      =   curVal & CHCFG_MOD_MASK;
		ctc_conf_data[cntr].cr_direction =   curVal & CHCFG_DIR_MASK;
	}
       return ctc_conf_data;
}

/**
 * =====================================================================
 * @@brief Enable library debug printout and toggle debug flag.
 *
 * @@param toggle - if 1 - will toggle current flag and return the previous
 *                 flag value.\n
 *                 if 0 - just give current value without flag toggling.
 *
 * @@return previous/current debug flag
 */

int ctc_dbgPrintout(int toggle)
{
	int old_flg;

	old_flg = ctc_lib_glob_dbg_flag;

	if (toggle)
	    ctc_lib_glob_dbg_flag ^= 1;

	return old_flg;
}

/**
 * =====================================================================
 * ctc_getChannelStatus - Get current status of 8 output channels.
 *
 * @@param handle  - DAL handle
 * @@param outChan - massive to store current status in. Must be 8 integers long.
 *
 * Output channel can be either enabled or disabled.\n
 * Each value in @@outChan represents current status of the output channel.\n
 * (outChan[0] - for channel 1, outChan[7] - for channel 8, etc...)\n
 * If channel value is 0 - output channel is disabled.\n
 * If channle value is one of [1 - 40] - output channel is active and
 * connected to the corresponding input channel.
 *
 * @@return OK           - all OK.
 * @@return -CTC_DAL_ERR - DAL return error.
 */

int ctc_getChannelStatus(HANDLE handle, int outChan[8])
{
	ctc_cfg_reg_t *data_p = NULL;
	int count_enb_reg;
	int cntr;

	if (!do_io(handle,&(map->cntr_enable),&count_enb_reg,DO_READ))
		return do_error(CTC_DAL_ERR);

	for (cntr = 0; cntr < L_OUT_CH; cntr++)
		outChan[cntr] =
			(count_enb_reg & (1 << (L_OUT_CH - cntr))) >>
			(L_OUT_CH - cntr);

	data_p = ctc_getChanConf(handle, 0 /*get all the channels*/ );
	if (data_p < 0)
		return (int) data_p;

	for (cntr = 0; cntr < L_OUT_CH; cntr++)
		if (outChan[cntr])
			outChan[cntr] = data_p[cntr].cr_ext_start;

	return OK;
}
@


1.2
log
@*** empty log message ***
@
text
@d4 3
d10 24
a34 1
#include <vmeio_support.h>
d36 7
a42 7
struct {
	unsigned int confChan;
	unsigned int clock1Delay;
	unsigned int clock2Delay;
	unsigned int outputCntr;
	unsigned int cntr1CurVal;
	unsigned int cntr2CurVal;
d45 3
a47 3
struct {
	unsigned int  status;
	unsigned int  cntr_enable;
d49 1
a49 1
} ctc_map_s;
d53 2
d57 1
a57 1
 * Helper routines to call RAW IO
d63 1
a63 1
static int do_io(HANDLE handle, int *offset, int *result, int flag)
d70 1
a70 1
	buf.buffer = &locRes;
d72 1
a72 1
	if (!RAW(handle,buf,flag))
d77 21
d112 1
a112 1
static int ctc_getInputChan(HANDLE handle, int chan, unsigned long *res)
d117 1
a117 1
		return -CTC_CH_OUT_OF_RANGE;
d119 2
a120 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d149 1
a149 1
		return -CTC_CH_OUT_OF_RANGE;
d152 1
a152 1
		return -CTC_CH_OUT_OF_RANGE;
d154 2
a155 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&curVal,DO_READ))
		return -CTC_DAL_ERR;
d161 2
a162 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d190 1
a190 1
		return -CTC_CH_OUT_OF_RANGE;
d192 2
a193 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d225 1
a225 1
		return -CTC_CH_OUT_OF_RANGE;
d227 2
a228 2
	if (newVal < 1) || (newVal > 6)
		return -CTC_CH_OUT_OF_RANGE;
d230 2
a231 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&curVal,DO_READ))
		return -CTC_DAL_ERR;
d236 2
a237 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d265 1
a265 1
		return -CTC_CH_OUT_OF_RANGE;
d267 2
a268 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d300 1
a300 1
		return -CTC_CH_OUT_OF_RANGE;
d302 2
a303 2
	if (newVal < 1) || (newVal > 6)
		return -CTC_CH_OUT_OF_RANGE;
d305 2
a306 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&curVal,DO_READ))
		return -CTC_DAL_ERR;
d311 2
a312 2
	if (!do_io(handle,&(map->channels[chan -1].confChan),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d335 1
a335 1
		return -CTC_CH_OUT_OF_RANGE;
d337 2
a338 2
	if (!do_io(handle,&(map->channels[chan -1].clock1Delay),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d362 1
a362 1
		return -CTC_CH_OUT_OF_RANGE;
d365 2
a366 2
	if (!do_io(handle,&(map->channels[chan -1].clock1Delay),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d368 3
a370 3
	curVal = nerwVal;
	if (!do_io(handle,&(map->channels[chan -1].clock1Delay),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d393 1
a393 1
		return -CTC_CH_OUT_OF_RANGE;
d395 2
a396 2
	if (!do_io(handle,&(map->channels[chan -1].clock2Delay),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d420 1
a420 1
		return -CTC_CH_OUT_OF_RANGE;
d423 2
a424 2
	if (!do_io(handle,&(map->channels[chan -1].clock2Delay),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d426 3
a428 3
	curVal = nerwVal;
	if (!do_io(handle,&(map->channels[chan -1].clock2Delay),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d451 1
a451 1
		return -CTC_CH_OUT_OF_RANGE;
d453 2
a454 2
	if (!do_io(handle,&(map->channels[chan -1].outputCntr),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d478 1
a478 1
		return -CTC_CH_OUT_OF_RANGE;
d480 2
a481 2
	if (!do_io(handle,&(map->channels[chan -1].cntr1CurVal),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d505 1
a505 1
		return -CTC_CH_OUT_OF_RANGE;
d507 2
a508 2
	if (!do_io(handle,&(map->channels[chan -1].cntr2CurVal),&locRes,DO_READ))
		return -CTC_DAL_ERR;
d530 1
a530 1
		return -CTC_DAL_ERR;
d571 2
a572 2
	if (!do_io(handle,&(map->enable),&curRegVal,DO_READ))
		return -CTC_DAL_ERR;
d575 2
a576 2
	if (!do_io(handle,&(map->enable),&curRegVal,DO_WRITE))
		return -CTC_DAL_ERR;
d583 2
a584 2
	if (!do_io(handle,&(map->enable),&curRegVal,DO_WRITE))
		return -CTC_DAL_ERR;
d586 2
a587 2
	if (!do_io(handle,&(map->enable),&curRegVal,DO_READ))
		return -CTC_DAL_ERR;
d595 1
a595 1
	      return -CTC_ERR;
d597 1
a597 1
       return(OK);
d620 1
a620 1
		return -CTC_CH_OUT_OF_RANGE;
d623 1
a623 1
		return -CTC_CH_OUT_OF_RANGE;
d628 1
a628 1
		return -CTC_ERR;
d630 2
a631 2
	if (!do_io(handle,&(map->enable),&curVal,DO_READ))
		return -CTC_DAL_ERR;
d635 2
a636 2
	if (!do_io(handle,&(map->enable),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d662 1
a662 1
		return -CTC_CH_OUT_OF_RANGE;
d664 2
a665 2
	if (!do_io(handle,&(map->enable),&curVal,DO_READ))
		return -CTC_DAL_ERR;
d669 2
a670 2
	if (!do_io(handle,&(map->enable),&curVal,DO_WRITE))
		return -CTC_DAL_ERR;
d687 1
a687 1
ctc_cfg_reg_t* ctc_getChanConf(HANDLE handle, int outChan)
d689 1
a689 1
	ctc_cfg_reg_t ctc_conf_data[L_OUT_CH];
d694 1
a694 1
			return -CTC_DAL_ERR;
a714 2
ctc_lib_glob_dbg_flag = 0;

d717 1
d719 1
a719 1
  int old_flg = ctc_lib_glob_dbg_flag;
d721 2
a722 2
  if (toggle)
    ctc_lib_glob_dbg_flag ^= 1;
d724 1
a724 1
  return old_flg;
d751 2
a752 2
	if (!do_io(handle,&(map->enable),&count_enb_reg,DO_READ))
		return -CTC_DAL_ERR;
d761 1
a761 1
		return data_p;
@


1.1
log
@Initial revision
@
text
@d8 1
a8 2

#define CHANNELS 8
d22 1
a22 1
	ctc_channel_s channels[CHANNELS];
d25 1
a25 1
struct ctc_map_s *map;
d32 3
d67 1
a67 1
	if ((chan < 0) || (chan > CHANNELS))
d70 1
a70 1
	if (!do_io(handle,&(map->channels[chan].confChan),&locRes,0))
d99 1
a99 1
	if ((chan < 0) || (chan > CHANNELS))
d105 1
a105 1
	if (!do_io(handle,&(map->channels[chan].confChan),&curVal,0))
d112 1
a112 1
	if (!do_io(handle,&(map->channels[chan].confChan),&curVal,1))
d140 1
a140 1
	if ((chan < 0) || (chan > CHANNELS))
d143 1
a143 1
	if (!do_io(handle,&(map->channels[chan].confChan),&locRes,0))
d175 1
a175 1
	if ((chan < 0) || (chan > CHANNELS))
d181 1
a181 1
	if (!do_io(handle,&(map->channels[chan].confChan),&curVal,0))
d187 1
a187 1
	if (!do_io(handle,&(map->channels[chan].confChan),&curVal,1))
d215 1
a215 1
	if ((chan < 0) || (chan > CHANNELS))
d218 1
a218 1
	if (!do_io(handle,&(map->channels[chan].confChan),&locRes,0))
d250 1
a250 1
	if ((chan < 0) || (chan > CHANNELS))
d256 1
a256 1
	if (!do_io(handle,&(map->channels[chan].confChan),&curVal,0))
d262 1
a262 1
	if (!do_io(handle,&(map->channels[chan].confChan),&curVal,1))
d283 1
a283 2
  int rid = 0;
  int dalrc;
d285 5
a289 9
  if ( (rid = CHECK_OUT_CHAN(chan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, chan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  if ( (dalrc = DaGetRegChunk(handle, rid, offsetof(CTCBlock01_t, clock1Delay)/sizeof(unsigned long), 1, res, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegChunk");
    return(-CTC_DAL_ERR);
  }
d291 2
a292 1
  return(OK);
d310 1
a310 20
  int rid = 0;
  unsigned long tmpTickVal = 0;
  int dalrc;

  if ( (rid = CHECK_OUT_CHAN(chan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, chan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  /* first - reset it to 0 */
  if ( (dalrc = DaSetRegChunk(handle, rid, offsetof(CTCBlock01_t, clock1Delay)/sizeof(unsigned long), 1, &tmpTickVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegChunk");
    return(-CTC_DAL_ERR);
  }

  /* then set user value */
  if ( (dalrc = DaSetRegChunk(handle, rid, offsetof(CTCBlock01_t, clock1Delay)/sizeof(unsigned long), 1, &newVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegChunk");
    return(-CTC_DAL_ERR);
  }
d312 12
a323 1
  return(OK);
d341 1
a341 2
  int rid = 0;
  int dalrc;
d343 2
a344 9
  if ( (rid = CHECK_OUT_CHAN(chan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, chan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  if ( (dalrc = DaGetRegChunk(handle, rid, offsetof(CTCBlock01_t, clock2Delay)/sizeof(unsigned long), 1, res, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegChunk");
    return(-CTC_DAL_ERR);
  }
d346 5
a350 1
  return(OK);
d368 1
a368 20
  int rid = 0;
  unsigned long tmpTickVal = 0;
  int dalrc;

  if ( (rid = CHECK_OUT_CHAN(chan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, chan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  /* first, reset it to 0 */
  if ( (dalrc = DaSetRegChunk(handle, rid, offsetof(CTCBlock01_t, clock2Delay)/sizeof(unsigned long), 1, &tmpTickVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegChunk");
    return(-CTC_DAL_ERR);
  }

  /* now set user value */
  if ( (dalrc = DaSetRegChunk(handle, rid, offsetof(CTCBlock01_t, clock2Delay)/sizeof(unsigned long), 1, &newVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegChunk");
    return(-CTC_DAL_ERR);
  }
d370 12
a381 1
  return(OK);
d399 4
a402 2
  int rid = 0;
  int dalrc;
d404 2
a405 9
  if ( (rid = CHECK_OUT_CHAN(chan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, chan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  if ( (dalrc = DaGetRegChunk(handle, rid, offsetof(CTCBlock01_t, outputCntr)/sizeof(unsigned long), 1, res, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegChunk");
    return(-CTC_DAL_ERR);
  }
d407 2
a408 1
  return(OK);
d426 4
a429 2
  int rid = 0;
  int dalrc;
d431 2
a432 9
  if ( (rid = CHECK_OUT_CHAN(chan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, chan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  if ( (dalrc = DaGetRegChunk(handle, rid, offsetof(CTCBlock01_t, cntr1CurVal)/sizeof(unsigned long), 1, res, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegChunk");
    return(-CTC_DAL_ERR);
  }
d434 2
a435 1
  return(OK);
d453 1
a453 2
  int rid = 0;
  int dalrc;
d455 5
a459 9
  if ( (rid = CHECK_OUT_CHAN(chan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, chan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  if ( (dalrc = DaGetRegChunk(handle, rid, offsetof(CTCBlock01_t, cntr2CurVal)/sizeof(unsigned long), 1, res, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegChunk");
    return(-CTC_DAL_ERR);
  }
d461 2
a462 1
  return(OK);
d478 1
a478 1
  int dalrc;
d480 2
a481 4
  if ( (dalrc = DaGetRegister(handle, STATUS_ID, res, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegister");
    return(-CTC_DAL_ERR);
  }
d483 2
a484 1
  return(OK);
d519 10
a528 38
  volatile unsigned long curRegVal;
  int cntr;
  int dalrc;

  if ( (dalrc = DaGetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegister");
    return(-CTC_DAL_ERR);
  }

  curRegVal = 1; /*  */

  if ( (dalrc = DaSetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegister");
    return(-CTC_DAL_ERR);
  }

  curRegVal = 0; /* change module reset bit to zero and reset all the channels,
		    so that next time we'll write some value into reset
		    register, no module reset will be performed by accident */

  if ( (dalrc = DaSetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegister");
    return(-CTC_DAL_ERR);
  }

  if ( (dalrc = DaGetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegister");
    return(-CTC_DAL_ERR);
  }

  /* set all channel inputs and counter delays to zero */
  for (cntr = 1; cntr <= 8; cntr++)
    if ( ctc_setInputChan(handle, cntr, 0) ||
	 ctc_setClock1Tick(handle, cntr,0) ||
	 ctc_setClock2Tick(handle, cntr,0) ) {
      fprintf(stderr, "      `----> called from %s()\n", __FUNCTION__);
      return(-CTC_ERR);
    }
d530 19
a548 1
  return(OK);
d568 17
a584 31
  int rid = 0;
  volatile unsigned long curRegVal = 0;
  int dalrc;

  if ( (rid = CHECK_OUT_CHAN(outChan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, outChan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  if (!WITHIN_RANGE(F_INP_CH, inpChan, L_INP_CH)) {
    fprintf(stderr, "\nCTClib@@%s(): Input channel (#%d) out of range!\n", __FUNCTION__, inpChan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  /* set input channel in config register of the channel */
  if (ctc_setInputChan(handle, outChan, inpChan)) {
    fprintf(stderr, "      `----> called from %s()\n", __FUNCTION__);
    return(-CTC_ERR);
  }

  if ( (dalrc = DaGetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegister");
    return(-CTC_DAL_ERR);
  }

  curRegVal |= 1 << (F_OUT_CH + L_OUT_CH - outChan);

  if ( (dalrc = DaSetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegister");
    return(-CTC_DAL_ERR);
  }
d586 4
a589 1
  return(OK);
d610 4
a613 20
  int rid = 0;
  volatile unsigned long curRegVal = 0;
  int dalrc;

  if ( (rid = CHECK_OUT_CHAN(outChan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, outChan);
    return(-CTC_CH_OUT_OF_RANGE);
  }

  if ( (dalrc = DaGetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaGetRegister");
    return(-CTC_DAL_ERR);
  }

  curRegVal &= ~(1 << (F_OUT_CH + L_OUT_CH - outChan));

  if ( (dalrc = DaSetRegister(handle, CNTR_ENABLE_ID, (void*)&curRegVal, sizeof(unsigned long))) != 1) {
    CTC_PRNT_DAL_ERR("DaSetRegister");
    return(-CTC_DAL_ERR);
  }
d615 9
a623 2
  return(OK);
  //return(ctc_setInputChan(handle, outChan, 0));
d631 1
a631 1
 * @@param outChan - output channel to exploit. [1, 8] range (0 for all of them)
d640 2
a641 24
  static ctc_cfg_reg_t ctc_conf_data[L_OUT_CH];
  CTCBlock01_t blk_data[L_OUT_CH];
  int dalrc, cntr;
  int rid = 0;

  if ( (rid = CHECK_OUT_CHAN(outChan)) == -1) {
    fprintf(stderr, "\nCTClib@@%s(): Output channel (#%d) out of range!\n", __FUNCTION__, outChan);
    return((ctc_cfg_reg_t*)-CTC_CH_OUT_OF_RANGE);
  }

  /* get info about all CTC output channels */
  if ( (dalrc = DaGetRegister(handle, ALL_CHANNELS_ID, (void*)blk_data, sizeof(blk_data))) != DaGetRegDepth(handle, ALL_CHANNELS_ID)) {
    CTC_PRNT_DAL_ERR("DaGetRegister");
    return((ctc_cfg_reg_t*)-CTC_DAL_ERR);
  }

  /* put config data into the structure for the user */
  for (cntr = 0; cntr < L_OUT_CH; cntr++) {
    ctc_conf_data[cntr].cr_ext_start = ((blk_data[cntr].confChan&CHCFG_ESC_MASK)>>CHCFG_ESC_SHIFT) + 1;
    ctc_conf_data[cntr].cr_cntr1_clk = ((blk_data[cntr].confChan&CHCFG_C1S_MASK)>>CHCFG_C1S_SHIFT) + 1;
    ctc_conf_data[cntr].cr_cntr2_clk = ((blk_data[cntr].confChan&CHCFG_C2S_MASK)>>CHCFG_C2S_SHIFT) + 1;
    ctc_conf_data[cntr].cr_mode      = blk_data[cntr].confChan & CHCFG_MOD_MASK;
    ctc_conf_data[cntr].cr_direction = blk_data[cntr].confChan & CHCFG_DIR_MASK;
  }
d643 10
a652 1
  return(ctc_conf_data);
d666 2
d670 1
d676 1
a676 1
  return(old_flg);
d703 1
a703 3
	if ( (DaGetRegister(handle, CNTR_ENABLE_ID, &count_enb_reg,
			    sizeof(count_enb_reg))) <= 0) {
		printf("Can't get channel status.\n");
a704 1
	}
d711 3
a713 5
	data_p = ctc_getChanConf(handle, 0/*get all the channels*/);
	if (IS_CTC_ERR(data_p)) {
		printf("Can't get channel configuration.\n");
		return PTR_CTC_ERR(data_p);
	}
@
